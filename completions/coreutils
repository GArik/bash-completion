# Completions for various core utilities

# chown(1) completion
#
have chown &&
_chown()
{
    local cur prev words cword split
    # Don't treat user:group as separate words.
    _init_completion -s -n : || return

    case "$prev" in
        --from)
            _usergroup
            return 0
            ;;
        --reference)
            _filedir
            return 0
            ;;
    esac

    $split && return 0

    if [[ "$cur" == -* ]]; then
        # Complete -options
        local w opts
        for w in "${words[@]}" ; do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break
        done
        COMPREPLY=( $( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --from --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ) )
    else
        local args

        # The first argument is an usergroup; the rest are filedir.
        _count_args :

        if [[ $args -eq 1 ]]; then
            _usergroup -u
        else
            _filedir
        fi
    fi
} &&
complete -F _chown chown


# chgrp(1) completion
#
have chgrp &&
_chgrp()
{
    local cur prev words cword split
    _init_completion -s || return

    cur=${cur//\\\\/}

    if [[ "$prev" == --reference ]]; then
        _filedir
        return 0
    fi

    $split && return 0

    # options completion
    if [[ "$cur" == -* ]]; then
        local w opts
        for w in "${words[@]}" ; do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break
        done
        COMPREPLY=( $( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ) )
        return 0
    fi

    # first parameter on line or first since an option?
    if [[ $cword -eq 1 && "$cur" != -* || "$prev" == -* ]]; then
        _allowed_groups "$cur"
    else
        _filedir || return 0
    fi

    return 0
} &&
complete -F _chgrp chgrp

# id(1) completion
#
have id &&
_id()
{
    local cur prev words cword
    _init_completion || return

    if [[ "$cur" == -* ]]; then
        local opts=$( _parse_help "$1" )
        [[ $opts ]] || opts="-G -g -u" # POSIX fallback
        COMPREPLY=( $( compgen -W "$opts" -- "$cur" ) )
    else
        COMPREPLY=( $( compgen -u "$cur" ) )
    fi
} &&
complete -F _id id

# mktemp(1) completion
#
have mktemp &&
_mktemp()
{
    local cur prev words cword split
    _init_completion -s || return

    case "$prev" in
        --help|--version|--suffix)
            return 0
            ;;
        --tmpdir|-p)
            _filedir -d
            return 0
            ;;
    esac

    $split && return 0

    if [[ "$cur" == -* ]]; then
        local opts=$( _parse_help "$1" )
        [[ $opts ]] || opts="-d -u -q -p -t" # non-GNU fallback
        COMPREPLY=( $( compgen -W "$opts" -- "$cur" ) )
        [[ $COMPREPLY == *= ]] && compopt -o nospace
    fi
} &&
complete -F _mktemp mktemp

# nice(1) completion
#
have nice &&
_nice()
{
    local offset i
    offset=0
    for (( i=1; i <= COMP_CWORD; i++ )); do
        if [[ "${COMP_WORDS[i]}" == -@(n|-adjustment) ]]; then
            ((i++))
            [[ $i -lt $COMP_CWORD && ${COMP_WORDS[i]} == '=' ]] && ((i++))
        elif [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i
            break
        fi
    done

    if [[ $offset -gt 0 && $offset -lt $COMP_CWORD ]]; then
        _command_offset $offset
        return
    fi

    local cur prev words cword split
    _init_completion -s || return

    if [[ "$prev" == -@(n|-adjustment) ]]; then
        COMPREPLY=( $( compgen -W '{-20..19}' -- "$cur" ) )
        return 0
    fi

    $split && return 0

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $( compgen -W '$( _parse_help "$1" --help )' -- "$cur" ) )
        [[ $COMPREPLY == *= ]] && compopt -o nospace
        return 0
    fi

    _filedir
} && complete -F _nice nice

# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
